Title: Jouons avec le pattern matching en Haskell
Date: 2016-09-27 00:00
Tags: haskell, pattern-matching
Slug: haskell-pattern-matching
Author: Nicolas Kosinski
Summary: D√©couvrons par l'exemple le pattern matching en Haskell.
Lang: fr

D√©couvrons le pattern matching en Haskell en reprenant l'exemple des cartes √† jouer utilis√© dans l'article ["Jouons avec le pattern matching en Scala"](https://nicokosi.github.io/scala-pattern-matching.html).

<br/>
## Pr√©ambule : cr√©ation d'une √©num√©ration

Codons notre √©num√©ration correspondant √† nos quatre enseignes (carreau, c≈ìur, pique et tr√®fle) :
```haskell
data Enseigne = Carreau | Coeur | Pique | Tr√®fle
  deriving (Eq, Enum, Show)
```
Nous venons de cr√©er notre propre type (_data type_) qui :

* a quatre constructeurs (_value constructors_)
* h√©rite des classes de base :
    * `Eq` pour impl√©menter l'√©galit√© entre deux valeurs
    * `Enum` pour que les valeurs sont finies et ordonn√©es (_sequentially ordered types_)
    * `Show` pour avoir une repr√©sentation sous forme de cha√Æne de caract√®res, ce qui peut √™tre utile pour d√©bugguer ou pour √©valuer interactivement du code via le REPL.


Utilisons maintenant `ghci` (_Glascow Haskell Compiler Interactive environment_), le REPL d'Haskell, pour interagir avec cette √©num√©ration :
```haskell
*Main> Coeur == Coeur
True
*Main> succ Coeur
Pique
```

<br/>

## Exemples de pattern matching

### Premier exemple basique

La fonction suivante retourne le symbole d'une enseigne :
```haskell
symbole :: Enseigne -> String
symbole enseigne =
  case enseigne of
    Carreau ->"‚ô¶"
    Coeur -> "‚ô•"
    Pique -> "‚ô†"
    Tr√®fle -> "‚ô£"    
```
Exemple d'appel :
```haskell
*Main> putStrLn $ symbole $ Coeur
‚ô•
```

Notons que :

* L'op√©rateur `$` nous permet de cha√Æner nos fonctions, plut√¥t que de les imbriquer dans des parenth√®ses (`putStrLn(symbole(Coeur))`).
* la fonction `putStrLn` permet d'afficher des caract√®res Unicode, √† l'inverse de la fonction standard `show` qui ne retourne que des cha√Ænes ASCII. üòé

<br/>
Remarque : le compilateur sait d√©tecter un pattern matching non exhaustif. Par exemple, le code suivant :
```haskell
symbole :: Enseigne -> String
symbole enseigne = case enseigne of
    Carreau ->"‚ô¶"
```
g√©n√®re un avertissement de compilation :
```haskell
warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In a case alternative:
        Patterns not matched:
            Coeur
            Pique
            Tr√®fle
```
Et l'appel de cette fonction g√©n√©re une exception :
```haskell
*Main> symbole Coeur
"*** Exception: test.hs:(5,20)-(6,17): Non-exhaustive patterns in case
```

<br/>

### Deuxi√®me exemple, partage d'expression via un bloc 'where'

Autre exemple, impl√©mentons une fonction `couleur` qui retourne la couleur d'une enseigne (cha√Æne de caract√®res "rouge" ou "noir") :

```haskell
couleur :: Enseigne -> String
couleur enseigne = case enseigne of
    Carreau -> rouge
    Coeur -> rouge
    Pique -> noir
    Tr√®fle -> noir
    where
      rouge = "rouge"
      noir = "noir"
```

Exemple d'appel :
```
*Main> couleur(Coeur)
"rouge"
```

Nous avons ici utilis√© le mot-cl√© `where` qui nous permet de partager des expressions.
<br/>
<br/>

### Troisi√®me exemple, d√©structuration

D√©finissons notre propre type `Carte` combinant un rang (1, 2, 3, ..., valet, dame, roi) et une enseigne :

```haskell
data Rang =
  R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | Valet | Dame | Roi
  deriving (Eq, Ord, Enum, Show)

data Carte = Carte {
  rang :: Rang,
  enseigne :: Enseigne
} deriving (Eq, Show)
```
Le type `Carte` utilise la syntaxe _record_ permettant de nommer les champs.

Nous pouvons ainsi utiliser le pattern matching pour "d√©structurer" une carte en filtrant les champs. Par exemple, la fonction suivante permet de d√©terminer si deux cartes, associ√©es par un _tuple_, sont de m√™me enseigne :

```haskell
m√™meEnseigne :: (Carte, Carte) -> Bool
m√™meEnseigne ((Carte _ enseigne1), (Carte _ enseigne2)) =
  enseigne1 == enseigne2
```

Exemples d'appel :
```
*Main> :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=R1, enseigne=Carreau},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
False
*Main> :{
*Main| m√™meEnseigne (
*Main|     Carte {rang=Valet, enseigne=Coeur},
*Main|     Carte {rang=R1, enseigne=Coeur} )
*Main| :}
True
```

Les rangs, que l'on n'utilise pas dans la fonction, ont √©t√© filtr√©s via le caract√®re _wild-card_ (`_`).

Et voil√† ! ü§ì
